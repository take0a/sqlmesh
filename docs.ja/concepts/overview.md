# 概要

このページでは、SQLMesh の機能とそのコンポーネントの連携について概念的に説明します。

## SQLMesh とは

SQLMesh は、スケーラブルなデータ変換プラットフォームの実行に必要なすべてを自動化する Python フレームワークです。SQLMesh は、さまざまな [エンジンとオーケストレーター](../integrations/overview.md) と連携します。

SQLMesh は、データと組織の規模の両方に重点を置いて開発されており、データウェアハウスや SQL エンジンの機能に関係なく動作します。

SQLMesh は、[CLI](../reference/cli.md)、[Notebook](../reference/notebook.md)、または [Python](../reference/python.md) API で使用できます。

## SQLMesh の仕組み

### モデルの作成

まず、SQL または Python でビジネスロジックを記述します。モデルは、単一のテーブルまたはビューにデータを入力するコードと、モデル名などのメタデータプロパティで構成されます。

### 計画を立てる

大規模なデータシステムでは、新しいモデルの作成や既存モデルの変更が、下流プロセスに劇的な影響を及ぼす可能性があります。モデル間の複雑な相互依存関係により、単一のモデルへの変更でさえ、その影響を判断することが困難になります。

変更の論理的な影響を理解するだけでなく、実際に計算を実行するための時間とリソースを費やす前に、変更を実装するために必要な計算についても理解しておく必要があります。

SQLMeshは、「SQLMeshプラン」を作成することで、影響を受けるすべてのモデルと変更に伴う計算を自動的に識別します。[`plan`コマンド](../reference/cli.md#plan)を実行すると、SQLMeshは*コマンドで指定された環境*（例：dev、test、prod）用のプランを生成します。

プランは、直接的および間接的に影響を受けるモデルを自動的に識別することで、変更が環境に与える影響の全容を伝えます。これにより、変更がもたらすすべての影響を包括的に把握できます。

[プラン](./plans.md)の詳細については、こちらをご覧ください。

#### プランを適用する

[`plan`](../reference/cli.md#plan) を使用して環境変更の影響を把握した後、SQLMesh はプランを [`apply`](./plans.md#plan-application) して計算を実行することを提案します。ただし、実行される計算の範囲を決定する追加情報を提供する必要があります。

SQLMesh プランを適用するために必要な計算は、プランに反映されるコード変更と、指定したバックフィルパラメータの両方によって決まります。

「バックフィル」とは、変更されたモデルに合わせて既存のデータを更新するプロセスです。たとえば、モデルの変更によって計算方法が変更された場合、新しいモデルをデプロイすると、古い計算方法に基づく既存のデータはすべて不正確になります。バックフィルでは、計算方法が変更された既存のフィールドを再計算します。

ほとんどのビジネスデータは一時的です。つまり、各データファクトは特定の時点で収集されたものです。バックフィル計算の規模は、再計算が必要な履歴データの量に直接関係しています。

SQLMesh プランは、変更によってバックフィルが必要なモデルと日付を自動的に判断します。この情報に基づいて、プランを適用する前にバックフィルを実行する日付を指定します。

#### 仮想環境の構築

複雑なデータシステムの開発作業は、本番環境にデプロイする前にエラーを検出できるよう、非本番環境で実施する必要があります。

複数のデータ環境を使用する場合の課題の一つは、バックフィルなどの計算を非本番環境と本番環境の2回実行する必要があることです。このプロセスは時間と計算リソースを消費し、遅延や追加コストにつながります。

SQLMeshは、すべてのモデルバージョンとその変更の記録を保持することでこの問題を解決します。この記録を使用して、非本番環境で実行された計算が、本番環境で生成されるものと同じ出力を生成するタイミングを判断します。

SQLMeshは、同等の出力に関する知識を活用して**仮想環境**を作成します。これは、本番環境の古いテーブルへの参照を、非本番環境で新しく計算されたテーブルへの参照に置き換えることで実現します。これにより、非本番環境から本番環境へビューとテーブルを効果的に昇格させることができますが、*計算やデータの移動は*行われません。

SQLMesh は、運用環境のすべてを再計算するのではなく仮想環境を使用するため、運用環境への変更の反映が速く、ダウンタイムも発生しません。

## コードとデータをテストする

不良データはデータがないよりも悪いです。不良データをシステムから排除する最善の方法は、変換コードと結果をテストすることです。

### [テスト](./tests.md)

SQLMesh の「テスト」は、ソフトウェア開発における単体テストに似ています。単体テストでは、単一のモデルが単位となります。SQLMesh テストはモデルの *コード* を検証します。入力データと期待される出力を指定すると、SQLMesh がテストを実行し、期待される出力と実際の出力を比較します。

SQLMesh は、`plan` を適用すると自動的にテストを実行します。また、[`test` コマンド](../reference/cli.md#test) を使用してオンデマンドでテストを実行することもできます。

### [監査](./audits.md)

テストとは異なり、SQLMesh の「監査」は、実際のデータに適用されたモデルコードの結果を検証します。

監査を作成するには、0 行を返す SQL クエリを記述します。たとえば、`your_field` に `NULL` 値がないことを確認する監査クエリには、`WHERE your_field IS NULL` が含まれます。NULL が検出された場合、クエリは少なくとも 1 行を返し、監査は失敗します。

監査は柔軟性が高く、特定のモデルの内容に関連付けることも、[マクロ](./macros/overview.md) を使用して複数のモデルで使用できる監査を作成することもできます。SQLMesh には、NULL 値や重複値の検出など、一般的なユースケース向けにあらかじめ作成された監査も含まれています。

モデルに対して実行する監査を指定するには、モデルのメタデータプロパティに監査を追加します。プロジェクト全体に監査を適用するには、モデルのデフォルト設定に監査を追加します。

SQLMesh は、環境に `plan` を適用すると自動的に監査を実行します。また、[`audit` コマンド](../reference/cli.md#audit) を使用してオンデマンドで監査を実行することもできます。

## インフラストラクチャとオーケストレーション

企業のデータインフラストラクチャはそれぞれ異なります。SQLMeshは、使用するエンジンやオーケストレーションフレームワークに関して柔軟性を備えています。必要なのは、対象のSQL/アナリティクスエンジンへのアクセスだけです。

SQLMeshは、既存のインフラストラクチャを使用して、モデルのバージョンと処理されたデータ間隔を追跡します。SQLMeshは、内部メタデータ用にデータウェアハウス内に`sqlmesh`スキーマを自動的に作成します。
