# 仮想データ環境
*by [Iaroslav Zeigerman](https://github.com/izeigerman), [Tobiko Data Team](https://tobikodata.com/)*

この記事では、データ開発環境を管理する既存のアプローチが、生産性の低下とコスト増加につながる理由を、以下の点から説明します。

- **非効率** - 新しい環境を構築すると、通常、追加のコンピューティングコストとストレージコストが発生します。テスト済みの変更を本番環境にデプロイすると、追加のオーバーヘッドが発生します。
- **スケーラビリティが低い** - 複数の環境と同時変更の管理は、特に大規模な組織では時間がかかり、エラーが発生しやすい手動プロセスです。
- **安全ではない** - 特に変更を同時にデプロイする場合、開発中に観察された結果が本番環境で再現できるという保証はありません。

[仮想データ環境](#virtual-data-environments-1)を紹介します。これは、低コストで効率的、スケーラブル、そして安全で、使いやすく管理しやすいデータ環境を提供する、斬新なアプローチです。データパイプラインを作成または維持する必要があるすべての人の生産性を大幅に向上させます。

最後に、[SQLMesh](https://github.com/TobikoData/sqlmesh) における**仮想データ環境**の実装方法と、関連する各コアコンポーネントの詳細について説明します。
- データ[フィンガープリント](#fingerprinting)
- [変更の自動分類](#automatic-change-categorization)
- [物理](#physical-layer) レイヤーと [仮想](#virtual-layer) レイヤーの分離

## データ環境
環境は、ソフトウェアとデータの両方において、開発者が変更を安全に検証・デプロイするための一般的な手法です。ソフトウェアエンジニアは、仮想化（例：Docker）やオーケストレーション（例：Kubernetes）といったイノベーションを通じて、長年にわたり、信頼性と効率性を確保しながら、この環境構築を実現してきました。

データチームにはこうしたメリットの一部が備わっているものの、ソフトウェアエンジニアが享受できるレベルの効率性と信頼性を実現するための重要なイノベーションが不足しています。このギャップを埋めるのが、**仮想データ環境**です。

### 現在の状況
データ実務家は、環境を日常的に使用しています。例えば、**dbt** では、ユーザーは異なる *ターゲット* （データウェアハウス内の異なるスキーマへの接続、あるいは別々のデータウェアハウスインスタンスへの接続）を構成できます。

**dbt** のアプローチは、開発/テスト、ステージング、本番環境など、別々の環境にデータパイプラインをデプロイするのに十分であり、変更はターゲット環境にのみ適用され、他の環境のデータセットには影響が及ばないことを保証します。

![図 1: 分離されているが堅牢なデータウェアハウス環境](virtual_data_environments/isolated_rigid_envs.png)
*図 1: 分離されているが堅牢なデータウェアハウス環境*

しかし、組織の規模が大きくなり、複数のユーザーが（多くの場合同時に）反復処理と変更のプッシュを行うようになると、この開発プロセスは煩雑になります。課題には以下が含まれます。

1. 異なる環境にデータを取り込むのは困難です。一般的に、4つのアプローチがあります。

- 本番環境で使用されるデータの完全なコピーを作成する
- 本番データをダウンサンプリングしてサブセットを作成する
- 静的テストデータセットを使用する
- ランダム値を使用してデータセットを生成する

最初のアプローチは、非常に多くの計算負荷（ストレージのオーバーヘッドは言うまでもありません）を要し、コストを押し上げます。残りの3つのアプローチは、変更を本番環境データに適用した場合の影響を適切に予測するには不十分です。

2. パイプラインの変更を本番環境にデプロイする場合、その環境で再度適用する必要があります。これにより、追加の再計算が発生し、開発環境で観測された結果とは異なる結果になるリスクがあります。

3. 本番環境にデプロイされた後、変更はすぐには反映されません。つまり、コードとそれによって生成されたデータの間に不整合が生じる期間が発生します。

#### ステートフル開発環境

一部のツールはさらに一歩進んで、デプロイされたパイプラインのソースファイルの生のコンテンツに基づいて、環境の現在の状態のスナップショットを作成できるようになっています。

このアプローチは、新しい環境でどのパイプラインが変更されたかを判断するのに役立ち、ユーザーは本番環境データセットの変更されていない部分を開発環境の一部として再利用できます。

このアプローチのバリエーションとしては、dbt の [state](https://docs.getdbt.com/docs/deploy/project-state) + [defer](https://docs.getdbt.com/reference/node-selection/defer) メソッドや、Fivetran の [“smart runs”](https://www.fivetran.com/blog/how-we-execute-dbt-runs-faster-and-cheaper) が挙げられます。

![図 2: ソースファイルの生のコンテンツを比較して変更を検出する](virtual_data_environments/stateful_envs.png)
*図 2: ソースファイルの生のコンテンツを比較して変更を検出する*

このアプローチは明らかに改善されていますが、依然としていくつかの欠点があります。
- ユーザーは、変更が下流のデータセットに**間接的に**影響を与えるかどうかについて知らされないため、自らの判断に頼り、依存関係グラフ全体を再計算する（正確性）か、変更されたデータセットのみを再計算する（効率性）かを選択せざるを得ません。その中間の方法で再計算を行う場合、ユーザー側で慎重な手動操作が必要となり、エラーが発生しやすく、大規模な依存関係グラフには対応できません。
- 既存のデータセットは、新しい開発環境を作成する際には再利用できます。しかし、変更を本番環境にデプロイする際には再利用できません。前述のように、この方法では変更が最初から再計算され、同じ結果が得られる保証はありません。一方、既存の本番環境データとデプロイされたコードは、再計算中は同期されていない状態になります。
- 変更が本番環境にデプロイされると状態は破棄されるため、適用済みの変更を元に戻す際に、以前に構築したデータセットを再利用することはできません。

正確性と効率性の間にトレードオフは必要ないことを示します。どちらも犠牲にすることなく実現できます。

### 正確性か効率性か…両方ではない理由
以下のセクションでは、**仮想データ環境** の仕組みと、以下の機能を通じてユーザーが正確性と効率性の両方を実現する方法について説明します。
- 安全で分離された開発環境を迅速に構築でき、追加コストはほとんどかかりません。
- 新しい環境には、代表的なデータがすぐに取り込まれます。ユーザーによる操作や大規模なデータコピーは必要ありません。
- 変更の影響は自動的に特定されるため、影響を受けるすべての（そして唯一の）下流の依存関係を再計算できます。
- 同じデータセットの複数のバージョンが同時に共存するため、変更のロールバック/ロールフォワードが容易になります。
- 開発環境で事前に構築されたデータセットは、変更を本番環境にデプロイする際に安全に再利用できます。これにより、開発環境から本番環境への移行時に予期せぬ問題が発生するのを回避できます。
- 本番環境にデプロイされた変更は、基盤となるデータセットに即座に反映されます。そのため、本番環境のデータとそれを生成するコードは常に同期されています。

## 仮想データ環境
新しいデータ環境を安価かつ容易に立ち上げる場合、主な課題は、新しい環境に代表的なデータを取り込むことです。

ここで言う「代表的な」とは、提案された変更が本番環境のデータセットに与える影響を事前に確認し、適切に評価するために必要なデータを意味します。したがって、最も代表的なデータセットは本番環境のデータセットそのものであると考えるのが妥当です。

したがって、問題は「ある環境で適用された変更が他のすべての環境の既存のデータセットに影響を与えないようにしながら、環境間でデータセットを共有するにはどうすれば良いか」と定義できます。

より一般的には、提案された変更を完全に**分離**した状態で正確に**プレビュー**するために、適切な場合に既存のデータを**再利用**する方法を模索しています。

SQLMesh の仮想データ環境は、プラットフォームの以下の機能によってまさにこれを実現します。
- プラットフォームによって管理される各データセットは、SQL または Python を使用して [モデル](https://sqlmesh.readthedocs.io/en/stable/concepts/models/overview/) として定義されたロジックによって入力されます。既存のモデルに変更が加えられるたびに、このモデルの新しい [スナップショット](https://sqlmesh.readthedocs.io/en/stable/concepts/architecture/snapshots/) が作成され、一意の [フィンガープリント](https://sqlmesh.readthedocs.io/en/stable/concepts/architecture/snapshots/#fingerprinting) に関連付けられます。フィンガープリント自体は、モデルを構成する属性に基づいて計算されたハッシュの組み合わせです。デフォルトでは、各モデルスナップショットは独自のテーブルに書き込まれるか、独自のビューが更新されるため、競合が発生することなく、複数のバージョンのモデルを同時に存在させることができます。
- このプラットフォームは、モデルスナップショットが直接入力されたデータセット（物理テーブルまたはビュー）を公開しません。代わりに、[ビュー](https://en.wikipedia.org/wiki/View_(SQL)) を用いて実装された間接レイヤーを介してデータセットへのアクセスを提供します。これにより、本番環境でのデータセットバージョンの更新は、関連付けられたビューが参照するソースを入れ替えるだけで、アトミックかつほぼ瞬時に実行されます。最も優れた点は、この操作が、常にビューを参照し、基盤となる物理テーブルを参照しない下流のユーザーに対して完全に透過的であることです。ビューによって実現される間接レイヤーを**仮想レイヤー**、モデルスナップショットが直接入力されるテーブルとビューのレイヤーを**物理レイヤー**と呼びます。

![図 3: 仮想レイヤーを介して管理される環境](virtual_data_environments/virtual_envs.png)
*図 3: 仮想レイヤーを介して管理される環境*

これら 2 つの特性を組み合わせたものが **仮想データ環境** です。

### モデルのスナップショット
前述のように、モデルが変更されるたびに、その変更をキャプチャするための新しいモデルスナップショットが作成されます。各スナップショットは、スナップショットが生成された時点のモデルの状態を表します。SQLMeshでは、新しい[プラン](https://sqlmesh.readthedocs.io/en/stable/concepts/plans/)が作成され適用されると、スナップショットが自動的に生成されます。

#### フィンガープリント
各スナップショットは、「フィンガープリント」によって一意に識別されます。フィンガープリントは以下の属性で構成されます。
- モデルのデータハッシュは、このモデルによって生成されるデータセットに直接影響を与えるモデル属性から計算されます。属性には、モデルのクエリ、ストレージ形式、パーティションスキームなどが含まれます。このハッシュが変更されると、モデルは**直接**変更されたとみなされます。
- 上流モデルのデータハッシュ。これは、現在のモデルの上流モデルに適用されるデータハッシュ計算と同じもので、モデルの依存関係によって発生したデータ変更を捕捉します。このハッシュが変更されると、モデルは**間接**的に変更されたとみなされます。
- モデルのメタデータハッシュは、データ自体に影響を与えないモデル属性に基づいています。これには、所有権情報、説明、コメントなどのメタデータが含まれます。
- 上流モデルのメタデータハッシュは、モデルの依存関係におけるメタデータの変更を捕捉します。

さらに、[SQLGlot オプティマイザー](https://github.com/tobymao/sqlglot/blob/main/posts/python_sql_engine.md#optimizing) のおかげで、各 SQL クエリの標準バージョンを作成できるようになり、フォーマットや構造のリファクタリングなどの機能以外の変更がフィンガープリントに影響を与えなくなります。

#### 変更の自動分類
**直接** と **間接** の変更の違いは、プラン作成時に個々の変更を[分類](https://sqlmesh.readthedocs.io/en/stable/concepts/plans/#change-categories)する際に重要になります。

モデルが直接変更されるたびに、SQLMesh は、変更が下流モデルに与える影響に基づいて、その変更を「互換性のない」（下流モデルが影響を受ける）または「互換性のない」（変更されたモデルのみが影響を受ける）に自動的に分類します。これは、プラットフォームが [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) レベルで SQL をセマンティックに理解できる能力によって可能になります。現在のモデルバージョンと以前のバージョンを比較することで、[セマンティック差分](https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md)を計算できます。SQLMeshはこれをさらに分析し、下流のモデルへの影響を把握します。

例えば、新しい列の追加は互換性を損なう変更とはみなされませんが、既存の列の削除または変更は互換性を損なう変更とみなされます。

![図 4: 互換性を損なう変更と互換性のない変更](virtual_data_environments/change_categorization.png)
*図 4: 互換性を損なう変更と互換性のない変更*

このようにして、SQLMeshは正確性を確保しながら、必要な再計算の量を自動的に最小限に抑えます。ユーザーの介入は必要ありません。

現在、このアプローチは各モデル全体を検討する範囲を超えていません。しかし、SQLMesh はまもなく、列レベルの系統を判別する機能により、変更を *個々の列* ごとに分類するようになります。

これにより、下流で参照されていない列の削除などの変更が「破壊的」と分類されなくなるため、正確性と効率性のバランスをさらに細かく保つことができます。

![図 5: 列レベルの変更分類](virtual_data_environments/partial_breaking.png)
*図 5: 列レベルの変更分類*

#### 物理レイヤー
モデルが直接的または間接的に変更されると、その変更をキャプチャした新しいスナップショットが、**物理レイヤー** 内の固有のテーブル（またはビュー）に関連付けられます。このテーブル（またはビュー）の名前は、スナップショットのフィンガープリントに基づいています。

つまり、同じモデルの異なるバージョンが共存し、互いの出力を上書きすることなく同時に評価できます。プラットフォームは、個々のスナップショットの欠落データ間隔を追跡し、プラン適用時にデータギャップを自動的に[バックフィル](https://sqlmesh.readthedocs.io/en/stable/concepts/plans/#backfilling)します。

しかし、モデルのスナップショットだけでは不十分です。異なる環境でさまざまなデータセットバージョンを公開し、既存のワークフローを変更することなくこれらのバージョンをオンザフライで切り替えられるようにする必要があるためです。これらの両方の項目は、**仮想レイヤー** で処理されます。

### 仮想レイヤー
下流のコンシューマーまたはワークフローがモデルによって生成されたデータにアクセスする場合、**仮想レイヤー** の一部であるビューに対してクエリを実行します。

モデルのスナップショットによって生成された物理データセットには直接アクセスされません。そのため、SQLMesh は下流のコンシューマーに影響を与えることなく、ビューを更新して異なるデータセットバージョンを参照できます。これは、プログラミングにおけるポインタや参照の使用に似ています。

スナップショットが**仮想レイヤー** 内のどのビューからも参照されていない場合、設定可能な期間が経過すると、Janitor プロセスによって自動的にガベージコレクションされます。それまでは、スナップショットを使用することで、以前の時点の状態を低コストかつ迅速に復元できます。

このアイデアは新しいものではありません。 [Iceberg](https://iceberg.apache.org/)、[Delta Lake](https://delta.io/)、[Snowflake](https://www.snowflake.com/en/) などのストレージエンジンは、ストレージ層に同様の機能を実装しており、ユーザーはテーブルの複数のバージョン（スナップショット）を維持したり、個々のデータセットの低コストのシャロークローンを作成したりできます。

ただし、これらのバージョン/クローンは、基盤となるパイプラインやそれらを参照する依存関係グラフには一切結び付けられていないため、適切なコピーを正しく選択する責任はユーザーが負います。さらに、この方法で作成できる同じデータセットのコピーの数はかなり限られています。

これらのツールとは異なり、SQLMesh は仮想層アプローチを使用してデータセットグラフ全体（個々のデータセットではなく）を作成および管理し、実装は基盤となるストレージテクノロジーに完全に依存しません。

SQLMesh の各 [環境](https://sqlmesh.readthedocs.io/en/stable/concepts/environments/) は、モデルごとに 1 つずつビューがあり、各ビューは **物理レイヤー** のスナップショット テーブルを参照するビューの集合です。これは、Iceberg、Delta Lake、Snowflake、BigQuery など、ほとんどのデータ ウェアハウス テクノロジーで同様に機能します。

![図 6: 仮想データ環境のエンドツーエンド](virtual_data_environments/virtual_envs_end_to_end.png)
*図 6: 仮想データ環境のエンドツーエンド*

本番環境以外の環境に属するビューには、完全修飾名のスキーマ部分に環境名がサフィックスとして付加されます。たとえば、`db.model_a` データセットは本番環境ではその名前でアクセスされますが、`test` という名前の環境では `db__test.model_a` という名前が使用されます。これにより、本番環境に移行する前に変更を**プレビュー**できます。

新しい環境が作成されると、本番環境と同じスナップショットテーブルポインターセットが使用されます。新しい環境に変更が適用されると、新しいモデルのスナップショットが生成され、影響を受けるビューのみが更新されます。本番環境の一部であるビューは影響を受けません。このようにして、SQLMesh は環境の**分離**を保証します。

最後に、モデルの実装が本番環境と比較して（**直接**または**間接**に**変更されていない場合、プラットフォームは現在本番環境で使用されているのと同じスナップショットテーブルを安全に**再利用**できます。同様に、開発中に作成された新しいスナップショットテーブルは、変更が本番環境にプロモートされたときに安全に再利用できます。

## 結論
**仮想データ環境** により、SQLMesh は完全に**分離された**開発環境に、変更が本番環境に導入される前に完全な**プレビュー** を提供し、適切かつ安全な場合には本番環境のデータセットを**再利用** できます。これにより、ユーザーには次のような具体的なメリットがもたらされます。
- 新しい環境の作成は、新しいビューセットの作成のみなので、低コストです。
- **仮想** レイヤーと **物理** レイヤーが分離されているため、新しい環境ですぐにデータを利用できます。
- 変更とその下流への影響は自動的に分類されるため、効率性と正確性の両方が実現します。
- データの移動は行われず、**仮想レイヤー** に含まれるビューのみが更新されるため、変更のロールバックはほぼ瞬時に行われます。
- 本番環境への変更のデプロイは**仮想レイヤー** 操作であるため、開発中に確認された結果が本番環境でも完全に同じになり、データとコードが常に同期されます。

本番環境への変更のデプロイを効率化するため、私たちのチームは SQLMesh [CI/CD ボット](https://github.com/TobikoData/sqlmesh/blob/main/docs/integrations/github.md) をリリースします。このボットは、このプロセスの自動化に役立ちます。

ぜひ [Slack チャンネル](https://tobikodata.com/slack) にご参加いただき、最新情報をお待ちください。
